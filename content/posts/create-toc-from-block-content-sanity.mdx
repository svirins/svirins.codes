---
title: 'Create TOC (table of contents) from Sanity portable text'
summary: ''
publishedAt: '2024-05-01'
coverImage: '/assets/images/sanity.webp'
---

### 1. Get all _headings_ from the portable text:

```ts
*[_type == "post"] {
  "headings": yourContentField[length(style) == 2
    && string::startsWith(style, "h")]
}
```
result should be something like this:

```json
{
  0:{…} 2 properties
    headings:[…] 5 items
      0:{…} 5 properties
        style: h2
        _key: 86e626763053
        markDefs:[] 0 items
        children:[…] 1 item
          0: {...} 4 properties
            marks: [] 0 items
            text: My extracted header
            _key: 68e626305673
            _type: span
      _type:block
    ... // the rest of the response
}
```

### 2. Create a function to parse the headings:

```ts
import speakingurl from 'speakingurl';

/**
 * Filters the AST based on a given match function.
 *
 * @param {Array} ast - The abstract syntax tree to filter.
 * @param {Function} match - The match function used to determine if a node should be included in the filtered result.
 * @returns {Array} - The filtered result containing nodes that match the given match function.
 */
const filter = (ast, match) =>
  ast.reduce((acc, node) => {
    if (match(node)) acc.push(node);
    if (node.children) acc.push(...filter(node.children, match));
    return acc;
  }, []);

/**
 * Finds headings in the given AST and returns an array of objects containing the heading text and slug.
 *
 * @param {Object} ast - The AST to search for headings.
 * @returns {Array} - An array of objects containing the heading text and slug.
 */
const findHeadings = (ast) =>
  filter(ast, (node) => /h\d/.test(node.style)).map((node) => {
    const text = getChildrenText(node);
    const slug = speakingurl(text);
    return { ...node, text, slug };
  });

/**
 * Returns the concatenated text content of the children nodes.
 *
 * @param {Object} props - The props object containing the children nodes.
 * @returns {string} - The concatenated text content.
 */
export const getChildrenText = (props) =>
  props.children
    .map((node) => (typeof node === 'string' ? node : node.text || ''))
    .join('');

/**
 * Retrieves a value from an object using a given path.
 *
 * @param {object} object - The object to retrieve the value from.
 * @param {Array} path - An array representing the path to the desired value.
 * @returns {*} - The value found at the specified path.
 */
const get = (object, path) => path.reduce((prev, curr) => prev[curr], object);

/**
 * Returns the object path for a given path.
 * @param {Array} path - The path to convert into an object path.
 * @returns {Array} - The object path.
 */
const getObjectPath = (path) =>
  path.length === 0
    ? path
    : ['subheadings'].concat(path.join('.subheadings.').split('.'));


/**
 * Parses the given AST (Abstract Syntax Tree) to create an outline of subheadings.
 * 
 * @param {Object} ast - The AST representing the content.
 * @returns {Array} - An array of subheadings in the outline.
 */

export const parseOutline = (ast) => {
  const outline = { subheadings: [] };
  const headings = findHeadings(ast);
  const path = [];
  let lastLevel = 0;

  headings.forEach((heading) => {
    const level = Number(heading.style.slice(1));
    heading.subheadings = [];

    if (level < lastLevel) for (let i = lastLevel; i >= level; i--) path.pop();
    else if (level === lastLevel) path.pop();

    const prop = get(outline, getObjectPath(path));
    prop.subheadings.push(heading);
    path.push(prop.subheadings.length - 1);
    lastLevel = level;
  });

  return outline.subheadings;
}
```

### 3. Finally, use the function to create the TOC:

```jsx
import { getChildrenText } from 'lib/utils/createNestedSubheaders';
// Using 2 levels of nesting for brevity
// h2 = level 0, h3 and the rest are level 1
function TOC({ headings }) {
  return (
    <>
      <h3>Table of Contents:</h3>
      <ul>
        {headings.map((heading) => (
          <li
            key={heading._key}
            className={heading.style === 'h2' ? 'ml-2' : 'ml-6'}
          >
            <a href={'#' + heading._key}>{getChildrenText(heading)}</a>
          </li>
        ))}
      </ul>
    </>
  );
}
```
